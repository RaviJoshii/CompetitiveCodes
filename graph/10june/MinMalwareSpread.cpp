// https://leetcode.com/problems/minimize-malware-spread/
// Minimize Malware Spread
// https://leetcode.com/problems/minimize-malware-spread/discuss/486277/Java-dfs-intuitive-solution


#include<bits/stdc++.h>
using namespace std;
class items{
    public:
    int count=0;
    int val;
    int size;
    items(int size,int counts, int val){
        this->size=size;
        this->count=count;
        this->val=val;
    }
    items(){

    }
};
class Solution {
public:
    void dfs(int src,vector<bool> &visited,vector<vector<int>>& graph,items &temp,unordered_set<int> &uset){
        if(visited[src]){
            return;
        }
        temp.size++;
        visited[src]=true;
        
        if(uset.count(src)>0){
            temp.count++;
            temp.val=src;
        }
        for(int j=0;j<graph[src].size();j++){

            if(graph[src][j]==1){
                dfs(j,visited,graph,temp,uset);
            }
        }
    }
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        vector<bool> visited(graph.size(),false);
        // vector<vector<int>> newGraph(graph.size());
        // for(int i=0;i<graph.size();i++){
        //     for(int j=0;j<graph[i].size();j++){
        //         if(graph[i][j]==1){
        //             newGraph[i].push_back(j);
        //             newGraph[j].push_back(i);
        //         }
        //     }
        // }
        
        unordered_set<int> uset;
        for(auto num: initial){
            uset.insert(num);
        }
        int ansSize=-1;
        int ansVal=-1;
        for(int src=0;src<graph.size();src++){
            
                if(visited[src]==false){
                    items recAns(0,0,0);
                    dfs(src,visited,graph,recAns,uset);
                    if(recAns.count==1){
                        if(recAns.size>ansSize){
                            ansSize=recAns.size;
                            ansVal=recAns.val;
                        }else if(recAns.size==ansSize){
                            
                            ansVal=min(recAns.val,ansVal);
                        }
                        
                    }
                
            }
            
        }
        
        if(ansSize==-1){
            sort(initial.begin(),initial.end());
            return initial[0];
        }
        return ansVal;
    }
};
int main(){
    Solution s;
    vector<vector<int>> graph={{1,1,1},{1,1,1},{1,1,1}};
    vector<int>  initial = {1,2};
    cout<<s.minMalwareSpread(graph,initial); 
    return 0;
}